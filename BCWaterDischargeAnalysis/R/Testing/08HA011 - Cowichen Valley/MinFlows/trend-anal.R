# Dealing with Autocorrelation in time series using generalized least squares and arima
# This will use the summary data generated by the contract

# 2017-02-09 CJS First edition


options(useFancyQuotes=FALSE) # renders summary output corrects
options(width=200)

library(car)
library(ggfortify)
library(ggplot2)
library(Kendall)
library(lmtest)
library(lsmeans)
library(nlme)
library(plyr)
library(reshape2)


# Read in the data.
stats <- read.csv("08HA011-annual-summary-stat.csv", header=TRUE, 
                  as.is=TRUE, strip.white=TRUE)


stats.long <- reshape2::melt(stats,
                            id.var='Year',
                            variable.name="Statistic",
                            value.name='value',
                            stringsAsFactors=FALSE)
head(stats.long)


# do the analysis for each statistic
results <- dlply(stats.long, "Statistic", function (x){
   # make sure that values are sorted
   x <- x[ order(x$Year),]
   
   # Naive fit
   prelimplot <- ggplot2::ggplot(data=x, aes(x=Year, y=value))+
     ggtitle(paste(x$Statistic[1], " - Trend analysis"))+
     xlab("Year")+ylab("log(stats.long Pelts)")+
     geom_point(size=4)+
     geom_smooth(method="lm", color="black")

  
   # Compute the naive fit
   naive.fit <- lm(value ~ Year, data=x)
   
   # Get the residual plots from the naive fit
   resid <- data.frame(resid=resid(naive.fit),Year=x$Year)
   resid$lagresid <- c(NA, resid$resid[1:(length(resid$resid)-1)])
   residtimeplot <- ggplot2::ggplot(data=resid, aes(x=Year, y=resid))+
     ggtitle(paste(x$Statistic[1], " - Time plot of residuals from naive fit"))+
     geom_point()+
     geom_line()+
     geom_hline(yintercept=0)
   residlagplot <- ggplot2::ggplot(data=resid, aes(x=lagresid, y=resid))+
      ggtitle(paste(x$Statistic[1], " - Lag plot of residuals from naive fit"))+
      geom_point()
   
   # other standard diagnostic plots
   plotdiag <- autoplot(naive.fit)

   # check for autocorrelation using Durbin-Watson test.
   # You can use the durbinWatsontest in the car package or the
   #                 dwtest in the lmtest package
   # For small sample sizes both are fine; for larger sample sizes use the lmtest package
   # Note the difference in the default direction of the alternative hypothesis

   DW1 <- car::durbinWatsonTest(naive.fit) # from the car package

   DW2 <-lmtest::dwtest(naive.fit) # from the lmtest package

   # Fit a model allowing for autocorrelation using gls
   ar1.fit <- nlme::gls(value ~ Year, data=x,
                 correlation=corAR1(form=~1))
   
   # Fit a model allowing for autocorrelation using arima
   #arima.fit <-  with(x, arima(value, xreg=Year, order=c(1,0,0)))

   # return the results
   list(prelimplot   =prelimplot,
        naive.fit    =naive.fit,
        residtimeplot=residtimeplot,
        residlagplot=residlagplot,
        plotdiag = plotdiag,
        DW1      = DW1,
        DW2      = DW2,
        ar1.fit  = ar1.fit
#        arima.fit= arima.fit
   )
   
})

summary.report <- plyr::ldply(results, function(x){
   # extract summary of fit
   naive.slope <- coef(x$naive.fit)[2]
   naive.slope.se <- sqrt(diag(vcov(x$naive.fit)))[2]
   naive.slope.p  <- summary(x$naive.fit)$coefficients[ rownames(summary(x$naive.fit)$coefficients)=="Year",
                                                      "Pr(>|t|)"]
   autocorrelation   <- x$DW1$r
   autocorrelation.p <- x$DW2$p.value
  
   ar1.slope   <- coefficients(x$ar1.fit)[2]
   ar1.slope.se <- sqrt(diag(summary(x$ar1.fit)$varBeta))[2]
   ar1.slope.p <- summary(x$ar1.fit)$tTable[ rownames(summary(x$ar1.fit)$tTable)=="Year",
                                                      "p-value"]
   
   data.frame(naive.slope=naive.slope,
              naive.slope.se    = naive.slope.se,
              naive.slope.p     = naive.slope.p,
              autocorrelation   = autocorrelation,
              autocorrelation.p = autocorrelation.p,
              ar1.slope         = ar1.slope,
              ar1.slope.se      = ar1.slope.se,
              ar1.slope.p       = ar1.slope.p)
  
})
summary.report

